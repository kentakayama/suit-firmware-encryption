



SUIT                                                       H. Tschofenig
Internet-Draft                                                          
Intended status: Standards Track                              R. Housley
Expires: 15 February 2024                                 Vigil Security
                                                                B. Moran
                                                             Arm Limited
                                                                D. Brown
                                                                  Linaro
                                                             K. Takayama
                                                         SECOM CO., LTD.
                                                          14 August 2023


                  Encrypted Payloads in SUIT Manifests
                 draft-ietf-suit-firmware-encryption-14

Abstract

   This document specifies techniques for encrypting software, firmware
   and personalization data by utilizing the IETF SUIT manifest.  Key
   agreement is provided by ephemeral-static (ES) Diffie-Hellman (DH)
   and AES Key Wrap (AES-KW).  ES-DH uses public key cryptography while
   AES-KW uses a pre-shared key-encryption key.  Encryption of the
   plaintext is accomplished with conventional symmetric key
   cryptography.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 15 February 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.




Tschofenig, et al.      Expires 15 February 2024                [Page 1]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Conventions and Terminology . . . . . . . . . . . . . . . . .   4
   3.  Architecture  . . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  Encryption Extensions . . . . . . . . . . . . . . . . . . . .   7
   5.  Extended Directives . . . . . . . . . . . . . . . . . . . . .   8
   6.  Content Key Distribution Methods  . . . . . . . . . . . . . .   9
     6.1.  Content Key Distribution with AES Key Wrap  . . . . . . .  10
       6.1.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  10
       6.1.2.  Deployment Options  . . . . . . . . . . . . . . . . .  10
       6.1.3.  CDDL  . . . . . . . . . . . . . . . . . . . . . . . .  11
       6.1.4.  Example . . . . . . . . . . . . . . . . . . . . . . .  13
     6.2.  Content Key Distribution with Ephemeral-Static
           Diffie-Hellman  . . . . . . . . . . . . . . . . . . . . .  14
       6.2.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  14
       6.2.2.  Deployment Options  . . . . . . . . . . . . . . . . .  15
       6.2.3.  CDDL  . . . . . . . . . . . . . . . . . . . . . . . .  15
       6.2.4.  Context Information Structure . . . . . . . . . . . .  17
       6.2.5.  Example . . . . . . . . . . . . . . . . . . . . . . .  18
   7.  Firmware Updates on IoT Devices with Flash Memory . . . . . .  20
     7.1.  AES-CBC . . . . . . . . . . . . . . . . . . . . . . . . .  22
     7.2.  AES-CTR . . . . . . . . . . . . . . . . . . . . . . . . .  23
   8.  Complete Examples . . . . . . . . . . . . . . . . . . . . . .  24
     8.1.  AES Key Wrap Example with Write Directive . . . . . . . .  24
     8.2.  AES Key Wrap Example with Fetch + Copy Directives . . . .  25
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  25
   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  26
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  26
     11.1.  Normative References . . . . . . . . . . . . . . . . . .  26
     11.2.  Informative References . . . . . . . . . . . . . . . . .  27
   Appendix A.  Acknowledgements . . . . . . . . . . . . . . . . . .  28
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28









Tschofenig, et al.      Expires 15 February 2024                [Page 2]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


1.  Introduction

   Vulnerabilities with Internet of Things (IoT) devices have raised the
   need for a reliable and secure firmware update mechanism that is also
   suitable for constrained devices.  To protect firmware images the
   SUIT manifest format was developed [I-D.ietf-suit-manifest].  The
   SUIT manifest provides a bundle of metadata about the firmware for an
   IoT device, where to find the firmware image, and the devices to
   which it applies.

   The SUIT information model [RFC9124] details the information that has
   to be offered by the SUIT manifest format.  In addition to offering
   protection against modification, which is provided by a digital
   signature or a message authentication code, the firmware image may
   also be afforded confidentiality using encryption.

   Encryption prevents third parties, including attackers, from gaining
   access to the firmware binary.  Hackers typically need intimate
   knowledge of the target firmware to mount their attacks.  For
   example, return-oriented programming (ROP) [ROP] requires access to
   the binary and encryption makes it much more difficult to write
   exploits.

   The SUIT manifest provides the data needed for authorized recipients
   of the firmware image to decrypt it.  The firmware image is encrypted
   using a symmetric key.

   A symmetric key can be established using a variety of mechanisms;
   this document defines two approaches for use with the IETF SUIT
   manifest, namely:

   *  Ephemeral-Static (ES) Diffie-Hellman (DH), and

   *  AES Key Wrap (AES-KW) with a pre-shared key-encryption key (KEK).

   The former relies on asymmetric key cryptography while the latter
   uses symmetric key cryptography for content key distribution.

   Our goal was to reduce the number of content key distribution options
   and thereby increase interoperability between different SUIT manifest
   parser implementations.

   While the original motivating use case of this document was firmware
   encryption, SUIT manifests may require payloads other than firmware
   images to experience confidentiality protection, such as

   *  software packages,




Tschofenig, et al.      Expires 15 February 2024                [Page 3]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   *  personalization data,

   *  configuration data, and

   *  machine learning models.

   Hence, the term payload is used to generically refer to those objects
   that may be subject to encryption.

2.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   This document assumes familiarity with the IETF SUIT manifest
   [I-D.ietf-suit-manifest], the SUIT information model [RFC9124] and
   the SUIT architecture [RFC9019].

   The terms sender and recipient have the following meaning:

   *  Sender: Role of the entity that sends an encrypted payload.

   *  Recipient: Role of the entity that receives an encrypted payload.

   Additionally, we introduce the term "distribution system" (or
   distributor) to refer to an entity that knows the recipients of the
   firmware images.  For use of encryption it therefore either knows the
   public key of the recipient (for ES-DH), or the KEK (for AES-KW).
   The author on the other hand does not know the recipients, which is
   responsible for creating the firmware image.  It is important to note
   that the distribution system is far more than a file server.

   Finally, the following abbreviations are used in this document:

   *  Key Wrap (KW), defined in [RFC3394] (for use with AES)

   *  Key-Encryption Key (KEK) [RFC3394]

   *  Content-Encryption Key (CEK) [RFC5652]

   *  Ephemeral-Static (ES) Diffie-Hellman (DH) [RFC9052]







Tschofenig, et al.      Expires 15 February 2024                [Page 4]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


3.  Architecture

   [RFC9019] describes the architecture for distributing payloads and
   manifests from an author to devices.  It does, however, not detail
   the use of payload encryption.

   This document enhances this architecture to support encryption.  The
   author and the distribution system are logical roles.  In some
   deployments these roles are separated in different physical entities
   and in others they are co-located.

   Figure 1 shows the distribution system, which represents the firmware
   server and the device management infrastructure.

   To apply encryption the sender (author) needs to know the recipient
   (device).  For AES-KW the KEK needs to be known and, in case of ES-
   DH, the sender needs to be in possession of the public key of the
   recipient.  The public key and parameters may be in the recipient's
   X.509 certificate [RFC5280].  Furthermore, for ES-DH the recipients
   must be provisioned with a public key (or certificate) for digital
   signature verification of the manifest.

   With encryption the author cannot just create a manifest for the
   firmware image and sign it since the subsequent encryption step by
   the distribution system would invalidate the signature over the
   manifest.  (The content key distribution information is embedded
   inside the COSE_Encrypt structure, which is included in the SUIT
   manifest.)  Hence, the author has to collaborate with the
   distribution system.  The varying degree of collaboration is
   discussed below.





















Tschofenig, et al.      Expires 15 February 2024                [Page 5]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


                                              +----------+
                                              |  Author  |
    +----------+                              +----------+
    |  Device  |---+                               |
    |          |   |                               | Firmware +
    |          |   |                               | Manifest
    +----------+   |                               |
                   |                               |
                   |                               |
                   |                        +--------------+
    +----------+   |  Firmware + Manifest   | Distribution |
    |  Device  |---+------------------------|    System    |
    |          |   |                        +--------------+
    |          |   |
    +----------+   |
                   |
                   |
    +----------+   |
    |  Device  +---+
    |          |
    |          |
    +----------+

                Figure 1: Firmware Encryption Architecture.

   The author has several deployment options, namely

   *  The author, as the sender, obtains information about the
      recipients and their keys from the distribution system.  Then, it
      performs the necessary steps to encrypt the payload.  As a last
      step it creates one or more manifests.  The device(s)perform
      decryption and act as recipients.

   *  The author treats the distribution system as the initial
      recipient.  Then, the distribution system decrypts and re-encrypts
      the payload for consumption by the device (or the devices).
      Delegating the task of re-encrypting the payload to the
      distribution system offers flexiblity when the number of devices
      that need to receive encrypted payloads changes dynamically or
      when updates to KEKs or recipient public keys are necessary.  As a
      downside, the author needs to trust the distribution system with
      performing the re-encryption of the payload.

   If the author and distributor are separate entities, then the author
   must delegate encryption rights to the distributor.  By the principle
   of least privilege, this should only grant the distributor decryption
   and re-encryption rights.  There are two models:




Tschofenig, et al.      Expires 15 February 2024                [Page 6]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   1.  The distributor replaces the COSE_Encrypt in the manifest and
       then signs the manifest again.  However, the COSE_Encrypt
       structure is contained within a signed container, which presents
       a problem: replacing the COSE_Encrypt with a new one will cause
       the digest of the manifest to change, thereby changing the
       signature.  This means that the distributor must be able to sign
       the new manifest.  If this is the case, then the distributor
       gains the ability to construct and sign manifests, which allows
       the distributor the authority to sign code, effectively
       presenting the distributor with full control over the recipient.

   2.  The alternative is to use a two-manifest system, where the
       distributor constructs a new manifest that overrides the
       COSE_Encrypt using the dependency system defined in
       [I-D.ietf-suit-trust-domains].  This incurrs additional overhead:
       one additional signature verification and one additional
       manifest, as well as the additional machinery in the recipient
       needed for dependency processing.

   These two models also present different threat profiles for the
   distributor.  If the distributor only has encryption rights, then an
   attacker who breaches the distributor can only mount a limited
   attack: they can encrypt a modified binary, but the recipients will
   identify the attack as soon as they perform the required image digest
   check and revert back to a correct image immediately.

   However, if the distributor has the authority to sign a single
   manifest, this threat profile is substantially degraded: a successful
   breach of the distributor grants the attacker the ability to
   distribute whatever code they like to recipient devices.  The
   recipient will validate the signature of the code and run it without
   identifying the attack.  Because distributors typically must perform
   their re-encryption online in order to handle a large number of
   devices in a timely fashion, it is not possible to air-gap the
   distributor's signing operations.  This degrades the recommendations
   in [RFC9124], Section 4.3.17.

   It is strongly RECOMMENDED that distributors are implemented using a
   two-manifest system in order to distribute encryption keys without
   requiring re-signing of the manifest, despite the increase in
   complexity and greater number of signature verifications that this
   imposes on the recipient.

4.  Encryption Extensions

   This specification introduces a new extension to the SUIT_Parameters
   structure.




Tschofenig, et al.      Expires 15 February 2024                [Page 7]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   The SUIT encryption info parameter (called suit-parameter-encryption-
   info), see Figure 2, contains key distribution information.  It is
   carried inside the suit-directive-override-parameters or the suit-
   directive-set-parameters structure.  The content of the
   SUIT_Encryption_Info structure is explained in Section 6.1 (for AES-
   KW) and Section 6.2 (for ES-DH).  An implementation claiming
   conformance with this specification must implement support for this
   parameter.  A device may, however, support only one of the available
   key distribution techniques.

   SUIT_Parameters //= (suit-parameter-encryption-info
       => bstr .cbor SUIT_Encryption_Info)

   suit-parameter-encryption-info   = [TBD1: Proposed 19]

              Figure 2: CDDL of the SUIT_Parameters Extension.

5.  Extended Directives

   This specification extends these directives:

   *  Directive Write (suit-directive-write) to decrypt the content
      specified by suit-parameter-content with suit-parameter-
      encryption-info.

   *  Directive Copy (suit-directive-copy) to decrypt the content of the
      component specified by suit-parameter-source-component with suit-
      parameter-encryption-info.

   Examples of the two directives are shown below.

   Figure 3 illustrates the Directive Write.

   / directive-override-parameters / 20, {
     / parameter-content / 18: h'EA1CED',
     / parameter-encryption-info / 19: h'D860E1A1F0'
   },
   / directive-write / 18, 15
   / NOTE: decrypt h'EA1CED' using h'D860E1A1F0' /
   / NOTE: plaintext payload is stored into component #0 /

        Figure 3: Example showing the Extended suit-directive-write.

   Figure 4 illustrates the Directive Copy.







Tschofenig, et al.      Expires 15 February 2024                [Page 8]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   / directive-set-component-index / 12, 1,
   / directive-override-parameters / 20, {
     / parameter-uri / 21: "http://example.com/encrypted.bin",
   },
   / directive-fetch / 21, 15,
   / NOTE: encrypted payload is stored into component #1 /
   / directive-set-component-index / 12, 0,
   / directive-override-parameters / 20, {
     / parameter-source-component / 22: 1,
     / parameter-encryption-info / 19: h'D860E1A1F0'
   },
   / directive-copy / 22, 15
   / NOTE: decrypt component #1 using h'D860E1A1F0' /
   / NOTE: plaintext payload is stored into component #0 /

        Figure 4: Example showing the Extended suit-directive-copy.

   The payload to be encrypted may be detached and, in that case, it is
   not covered by a digital signature or a MAC of the manifest.  (To be
   more precise, the suit-authentication-wrapper found in the envelope
   contains a digest of the manifest in the SUIT Digest Container.)  The
   lack of authentication and integrity protection of the payload is
   particularly a concern when a cipher without integrity protection is
   used.  To authenticate the payload in the attached payload case a
   SUIT Digest Container with the digest of the encrypted and/or
   plaintext payload MUST be included in the manifest.

   An attacker may, of example, swaps detached payloads and thereby
   force the device to process a wrong payload.  This can lead to
   battery exhaustion attacks where an adversary expends energy and
   flash cycles of the device.

   Including the digest of the encrypted payload allows the device to
   detect incorrectly encrypted before decryption took place.  Including
   the digest of the plaintext payload is adequate when battery
   exhaustion attacks are not a concern.

6.  Content Key Distribution Methods

   The sub-sections below describe two content key distribution
   mechanisms, namely AES Key Wrap (AES-KW) and Ephemeral-Static Diffie-
   Hellman (ES-DH).  Other mechanisms are supported by COSE and may be
   supported via enhancements to this specification.

   When an encrypted firmware image is sent to multiple recipients,
   there are different deployment options.  To explain these options we
   use the following notation:




Tschofenig, et al.      Expires 15 February 2024                [Page 9]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   *  KEK(R1,S) refers to a KEK shared between recipient R1 and the
      sender S.  The KEK, as a concept, is used by AES Key Wrap.

   *  CEK(R1,S) refers to a CEK shared between R1 and S.

   *  CEK(_,S) or KEK(_,S) are used when a single CEK or a single KEK is
      shared with all authorized recipients by a given sender S in a
      certain context.

   *  ENC(plaintext, k) refers to the encryption of plaintext with a key
      k.

   *  KEK_i or CEK_i refers to the i-th instance of the KEK or CEK,
      respectively.

6.1.  Content Key Distribution with AES Key Wrap

6.1.1.  Introduction

   The AES Key Wrap (AES-KW) algorithm is described in RFC 3394
   [RFC3394], and can be used to encrypt a randomly generated content-
   encryption key (CEK) with a pre-shared key-encryption key (KEK).  The
   COSE conventions for using AES-KW are specified in Section 8.5.2 of
   [RFC9052] and in Section 6.2.1 of [RFC9053].  The encrypted CEK is
   carried in the COSE_recipient structure alongside the information
   needed for AES-KW.  The COSE_recipient structure, which is a
   substructure of the COSE_Encrypt structure, contains the CEK
   encrypted by the KEK.

   The COSE_Encrypt structure conveys information for encrypting the
   payload, which includes information like the algorithm and the IV,
   even though the payload is not embedded in the
   COSE_Encrypt.ciphertext itself since it conveyed as detached content.

6.1.2.  Deployment Options

   There are three deployment options for use with AES Key Wrap for
   payload encryption:

   *  If all authorized recipients have access to the KEK, a single
      COSE_recipient structure contains the encrypted CEK.  The sender
      executes the following steps:

         Fetch KEK(*,S)
         Generate CEK
         ENC(CEK,KEK)
         ENC(payload,CEK)




Tschofenig, et al.      Expires 15 February 2024               [Page 10]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   *  If recipients have different KEKs, then multiple COSE_recipient
      structures are included but only a single CEK is used.  Each
      COSE_recipient structure contains the CEK encrypted with the KEKs
      appropriate for a given recipient.  The benefit of this approach
      is that the payload is encrypted only once with a CEK while there
      is no sharing of the KEK across recipients.  Hence, authorized
      recipients still use their individual KEK to decrypt the CEK and
      to subsequently obtain the plaintext.  The steps taken by the
      sender are:

         Generate CEK
         for i=1 to n {
            Fetch KEK_i(Ri, S)
            ENC(CEK, KEK_i)
         }
         ENC(payload,CEK)

   *  The third option is to use different CEKs encrypted with KEKs of
      authorized recipients.  Assume there are n recipients with their
      unique KEKs - KEK_1(R1, S),..., KEK_n(Rn, S).  The sender needs to
      make the following steps:

         for i=1 to n {
            Fetch KEK_i(Ri, S)
            Generate CEK_i
            ENC(CEK_i, KEK_i)
            ENC(payload,CEK_i)
         }

   This approach is appropriate when no benefits can be gained from
   encrypting and transmitting payloads only once.

6.1.3.  CDDL

   The CDDL for the COSE_Encrypt_Tagged structure is shown in Figure 5.
















Tschofenig, et al.      Expires 15 February 2024               [Page 11]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)

   SUIT_Encryption_Info = COSE_Encrypt_Tagged

   COSE_Encrypt = [
     protected   : bstr .cbor outer_header_map_protected,
     unprotected : outer_header_map_unprotected,
     ciphertext  : bstr / nil,
     recipients  : [ + COSE_recipient ]
   ]

   outer_header_map_protected =
   {
       1 => int,         ; algorithm identifier
     * label => values   ; extension point
   }

   outer_header_map_unprotected =
   {
       5 => bstr,        ; IV
     * label => values   ; extension point
   }

   COSE_recipient = [
     protected   : bstr .size 0,
     unprotected : recipient_header_map,
     ciphertext  : bstr        ; CEK encrypted with KEK
   ]

   recipient_header_map =
   {
       1 => int,         ; algorithm identifier
       4 => bstr,        ; key identifier
     * label => values   ; extension point
   }

          Figure 5: CDDL for AES-KW-based Content Key Distribution

   Note that the AES-KW algorithm, as defined in Section 2.2.3.1 of
   [RFC3394], does not have public parameters that vary on a per-
   invocation basis.  Hence, the protected header in the COSE_recipient
   structure is a byte string of zero length.

   The COSE specification requires a consistent byte stream for the
   authenticated data structure to be created.  This structure is shown
   in Figure 6.





Tschofenig, et al.      Expires 15 February 2024               [Page 12]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


          Enc_structure = [
            context : "Encrypt",
            protected : empty_or_serialized_map,
            external_aad : bstr
          ]

              Figure 6: CDDL for Enc_structure Data Structure

   This Enc_structure needs to be populated as follows:

   The protected field in the Enc_structure from Figure 6 refers to the
   content of the protected field from the COSE_Encrypt structure.  It
   is important to note that there are two protected fields shown in
   Figure 5:

   *  one in the COSE_Encrypt structure, and

   *  a second one in the COSE_recipient structure.

   The value of the external_aad MUST be set to a null value (major type
   7, value 22).

6.1.4.  Example

   This example uses the following parameters:

   *  Algorithm for payload encryption: AES-GCM-128

   *  Algorithm id for key wrap: A128KW

   *  IV: 0x26, 0x68, 0x23, 0x06, 0xd4, 0xfb, 0x28, 0xca, 0x01, 0xb4,
      0x3b, 0x80

   *  KEK: "aaaaaaaaaaaaaaaa"

   *  KID: "kid-1"

   *  Plaintext firmware (txt): "This is a real firmware image." (in
      hex): 546869732069732061207265616C206669726D7761726520696D6167652E

   The COSE_Encrypt structure, in hex format, is (with a line break
   inserted):

   D8608443A10101A1054C26682306D4FB28CA01B43B80F68340A2012204456B69642D
   315818AF09622B4F40F17930129D18D0CEA46F159C49E7F68B644D

   The resulting COSE_Encrypt structure in a diagnostic format is shown
   in Figure 7.



Tschofenig, et al.      Expires 15 February 2024               [Page 13]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   96([
     / protected: / << {
       / alg / 1: 1 / AES-GCM-128 /
     } >>,
     / unprotected: / {
       / IV / 5: h'1de460e8b5b68d7222c0d6f20484d8ab'
     },
     / payload: / null / detached ciphertext /,
     / recipients: / [
       [
         / protected: / << {
         } >>,
         / unprotected: / {
           / alg / 1: -3 / A128KW /,
           / kid / 4: 'kid-1'
         },
         / payload: CEK encrypted with KEK /
         h'a86200e4754733e4c00fc08c6a72cc1996e129922eab504f'
       ]
     ]
   ])

              Figure 7: COSE_Encrypt Example for AES Key Wrap

   The CEK, in hex format, was "4C805F1587D624ED5E0DBB7A7F7FA7EB".  The
   encrypted firmware (with a line feed added) was:

   A8B6E61EF17FBAD1F1BF3235B3C64C06098EA512223260
   F9425105F67F0FB6C92248AE289A025258F06C2AD70415

6.2.  Content Key Distribution with Ephemeral-Static Diffie-Hellman

6.2.1.  Introduction

   Ephemeral-Static Diffie-Hellman (ES-DH) is a scheme that provides
   public key encryption given a recipient's public key.  There are
   multiple variants of this scheme; this document re-uses the variant
   specified in Section 8.5.5 of [RFC9052].

   The following two layer structure is used:

   *  Layer 0: Has a content encrypted with the CEK.  The content may be
      detached.

   *  Layer 1: Uses the AES Key Wrap algorithm to encrypt a randomly
      generated CEK with the KEK derived with ES-DH whereby the
      resulting symmetric key is fed into the HKDF-based key derivation
      function.



Tschofenig, et al.      Expires 15 February 2024               [Page 14]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   As a result, the two layers combine ES-DH with AES-KW and HKDF.  An
   example is given in Figure 10.

6.2.2.  Deployment Options

   There are two deployment options with this approach.  We assume that
   recipients are always configured with a device-unique public /
   private key pair.

   *  A sender wants to transmit a payload to multiple recipients.  All
      recipients shall receive the same encrypted payload, i.e. the same
      CEK is used.  One COSE_recipient structure per recipient is used
      and it contains the CEK encrypted with the KEK.  To generate the
      KEK each COSE_recipient structure contains a COSE_recipient_inner
      structure to carry the sender's emphemeral key and an identifier
      for the recipients public key.

   The steps taken by the sender are:

         Generate CEK
         for i=1 to n {
            Generate KEK_i(Ri, S) using ES-DH
            ENC(CEK, KEK_i)
         }
         ENC(payload,CEK)

   *  The alternative is to encrypt a payload with a different CEK for
      each recipient.  Assume there are KEK_1(R1, S),..., KEK_n(Rn, S)
      have been generated for the different recipients using ES-DH.  The
      following steps needs to be made by the sender:

         for i=1 to n {
            Generate KEK_i(Ri, S) using ES-DH
            Generate CEK_i
            ENC(CEK_i, KEK_i)
            ENC(payload,CEK_i)
         }

   This results in n-manifests.  This approach is useful when payloads
   contain information unique to a device.  The encryption operation
   effectively becomes ENC(payload_i,CEK_i).

6.2.3.  CDDL

   The CDDL for the COSE_Encrypt_Tagged structure is shown in Figure 8.






Tschofenig, et al.      Expires 15 February 2024               [Page 15]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)

   SUIT_Encryption_Info = COSE_Encrypt_Tagged

   COSE_Encrypt = [
     protected   : bstr .cbor outer_header_map_protected,
     unprotected : outer_header_map_unprotected,
     ciphertext  : bstr / nil,
     recipients  : [ + COSE_recipient ]
   ]

   outer_header_map_protected =
   {
       1 => int,         ; algorithm identifier
     * label => values   ; extension point
   }

   outer_header_map_unprotected =
   {
       5 => bstr,        ; IV
     * label => values   ; extension point
   }

   COSE_recipient = [
     protected   : bstr .cbor recipient_header_pr_map,
     unprotected : recipient_header_unpr_map,
     ciphertext  : bstr        ; CEK encrypted with KEK
   ]

   recipient_header_pr_map =
   {
       1 => int,         ; algorithm identifier for key wrap
     * label => values   ; extension point
   }

   recipient_header_unpr_map =
   {
      -1 => COSE_Key,    ; ephemeral public key for the sender
       4 => bstr,        ; identifier of the recipient public key
     * label => values   ; extension point
   }

          Figure 8: CDDL for ES-DH-based Content Key Distribution








Tschofenig, et al.      Expires 15 February 2024               [Page 16]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


6.2.4.  Context Information Structure

   The context information structure is used to ensure that the derived
   keying material is "bound" to the context of the transaction.  This
   specification re-uses the structure defined in Section 5.2 of RFC
   9053 and tailors it accordingly.

   The following information elements are bound to the context:

   *  the protocol employing the key-derivation method,

   *  information about the utilized AES Key Wrap algorithm,and the key
      length.

   *  the protected header field, which contains the content key
      encryption algorithm.

   The sender and recipient identities are left empty in

   The following fields in Figure 9 require an explantation:

   *  The COSE_KDF_Context.AlgorithmID field contains the algorithm
      identifier for A128KW (value -4), A192KW (value -4), or A256KW
      (value -5).

   *  The COSE_KDF_Context.SuppPubInfo.keyDataLength field contains the
      key length of the algorithm in the COSE_KDF_Context.AlgorithmID
      field expressed as the number of bits.  For A128KW the value is
      128, for A192KW the value is 192, and for A256KW the value 256.

   *  The COSE_KDF_Context.SuppPubInfo.other field captures the protocol
      in which the ES-DH content key distribution algorithm is used and
      MUST be set to the constant string "SUIT Payload Encryption".

   *  The COSE_KDF_Context.SuppPubInfo.protected field serializes the
      content of the recipient_header_pr_map field, which (among other
      fields) contains the content key distribution algorithm
      identifier.













Tschofenig, et al.      Expires 15 February 2024               [Page 17]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   PartyInfoSender = (
       identity : bstr .size 0,
       nonce : nil,
       other : bstr .size 0
   )

   PartyInfoRecipient = (
       identity : bstr .size 0,
       nonce : nil,
       other : bstr .size 0
   )

   COSE_KDF_Context = [
       AlgorithmID : int,
       PartyUInfo : [ PartyInfoSender ],
       PartyVInfo : [ PartyInfoRecipient ],
       SuppPubInfo : [
           keyDataLength : uint,
           protected : bstr .cbor recipient_header_pr_map,
           other: bstr "SUIT Payload Encryption"
       ],
       SuppPrivInfo : bstr .size 0
   ]

               Figure 9: CDDL for COSE_KDF_Context Structure

   Profiles of this specification MAY specify an extended version of the
   context information structure or MAY utilize a different context
   information structure.

6.2.5.  Example

   This example uses the following parameters:

   *  Algorithm for payload encryption: AES-GCM-128

   *  IV: 0x26, 0x68, 0x23, 0x06, 0xd4, 0xfb, 0x28, 0xca, 0x01, 0xb4,
      0x3b, 0x80

   *  Algorithm for content key distribution: ES-DH + A128KW

   *  KID: "kid-1"

   *  Plaintext: "This is a real firmware image."

   *  Firmware (hex):
      546869732069732061207265616C206669726D7761726520696D6167652E




Tschofenig, et al.      Expires 15 February 2024               [Page 18]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   The COSE_Encrypt structure, in hex format, is (with a line break
   inserted):

   D8608443A10101A1054C26682306D4FB28CA01B43B805823F21AC5881CD6FC45754
   C65790F806C81A57B8D96C1988233BF40F670172405B5F107FD8444A101381C44A1
   01381CA220A401022001215820415A8ED270C4B1F10B0A2D42B28EE6028CE25D745
   52CB4291A4069A2E989B0F6225820CCC9AAF60514B9420C80619A4FF068BC1D7762
   5BA8C90200882F7D5B73659E7604456B69642D315818B37CCD582696E5E62E5D93A
   555E9072687D6170B122322EE

   The resulting COSE_Encrypt structure in a diagnostic format is shown
   in Figure 10.  Note that the COSE_Encrypt structure also needs to
   protected by a COSE_Sign1, which is not shown below.

   96(
     [
      / protected / h'a10101' / {
          \ alg \ 1:1 \ AES-GCM-128 \
        } / ,
      / unprotected / {
        / iv / 5:h'26682306D4FB28CA01B43B80'
        },
      / encrypted firmware /
       h'F21AC5881CD6FC45754C65790F806C81A57
         B8D96C1988233BF40F670172405B5F107FD',
       [
          / protected / h'A101381C' / {
              \ alg \ 1:-29 \ ES-DH + A128KW \
            } / ,
            h'A101381C',
          / unprotected / {
                / ephemeral / -1: {
                      / kty / 1:2,
                      / crv / -1:1,
                      / x / -2:h'415A8ED270C4B1F10B0A2D42B28EE602
                                 8CE25D74552CB4291A4069A2E989B0F6',
                      / y / -3:h'CCC9AAF60514B9420C80619A4FF068BC
                                 1D77625BA8C90200882F7D5B73659E76'
                    },
                    / kid / 4:'kid-1'
           },
           / ciphertext - CEK encrypted with KEK /
           h'B37CCD582696E5E62E5D93A555E9072687D6170B122322EE'
       ]
     ]
   )

                 Figure 10: COSE_Encrypt Example for ES-DH



Tschofenig, et al.      Expires 15 February 2024               [Page 19]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


7.  Firmware Updates on IoT Devices with Flash Memory

   Flash memory on microcontrollers is a type of non-volatile memory
   that erases data in units called blocks, pages or sectors and re-
   writes data at byte level (often 4-bytes).  Flash memory is
   furthermore segmented into different memory regions, which store the
   bootloader, different versions of firmware images (in so-called
   slots), and configuration data.  Figure 11 shows an example layout of
   a microcontroller flash area.  The primary slot contains the firmware
   image to be executed by the bootloader, which is a common deployment
   on devices that do not offer the concept of position independent
   code.

   When the encrypted firmware image has been transferred to the device,
   it will typically be stored in a staging area, in the secondary slot
   in our example.

   At the next boot, the bootloader will recognize a new firmware image
   in the secondary slot and will start decrypting the downloaded image
   sector-by-sector and will swap it with the image found in the primary
   slot.

   The swap should only take place after the signature on the plaintext
   is verified.  Note that the plaintext firmware image is available in
   the primary slot only after the swap has been completed, unless
   "dummy decrypt" is used to compute the hash over the plaintext prior
   to executing the decrypt operation during a swap.  Dummy decryption
   here refers to the decryption of the firmware image found in the
   secondary slot sector-by-sector and computing a rolling hash over the
   resulting plaintext firmware image (also sector-by-sector) without
   performing the swap operation.  While there are performance
   optimizations possible, such as conveying hashes for each sector in
   the manifest rather than a hash of the entire firmware image, such
   optimizations are not described in this specification.

   This approach of swapping the newly downloaded image with the
   previously valid image is often referred as A/B approach.  A/B refers
   to the two slots involved.  Two slots are used to allow the update to
   be reversed in case the newly obtained firmware image fails to boot.
   This approach adds robustness to the firmware update procedure.

   Since the image in primary slot is available in cleartext it may need
   to re-encrypted it before copying it to the secondary slot.  This may
   be necessary when the secondary slot has different access permissions
   or when the staging area is located in an off-chip flash memory and
   therefore more vulnerable to physical attacks.  Note that this
   description assumes that the processor does not execute encrypted
   memory (i.e. using on-the-fly decryption in hardware).



Tschofenig, et al.      Expires 15 February 2024               [Page 20]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   +--------------------------------------------------+
   | Bootloader                                       |
   +--------------------------------------------------+
   | Primary Slot                                     |
   |                                        (sector 1)|
   |..................................................|
   |                                                  |
   |                                        (sector 2)|
   |..................................................|
   |                                                  |
   |                                        (sector 3)|
   |..................................................|
   |                                                  |
   |                                        (sector 4)|
   +--------------------------------------------------+
   | Secondary Slot                                   |
   |                                        (sector 1)|
   |..................................................|
   |                                                  |
   |                                        (sector 2)|
   |..................................................|
   |                                                  |
   |                                        (sector 3)|
   |..................................................|
   |                                                  |
   |                                        (sector 4)|
   +--------------------------------------------------+
   | Swap Area                                        |
   |                                                  |
   +--------------------------------------------------+
   | Configuration Data                               |
   +--------------------------------------------------+

                    Figure 11: Example Flash Area Layout

   The ability to restart an interrupted firmware update is often a
   requirement for low-end IoT devices.  To fulfill this requirement it
   is necessary to chunk a firmware image into sectors and to encrypt
   each sector individually using a cipher that does not increase the
   size of the resulting ciphertext (i.e., by not adding an
   authentication tag after each encrypted block).

   When an update gets aborted while the bootloader is decrypting the
   newly obtained image and swapping the sectors, the bootloader can
   restart where it left off.  This technique offers robustness and
   better performance.





Tschofenig, et al.      Expires 15 February 2024               [Page 21]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   For this purpose ciphers without integrity protection are used to
   encrypt the firmware image.  Integrity protection for the firmware
   image must, however, be provided and the suit-parameter-image-digest,
   defined in Section 8.4.8.6 of [I-D.ietf-suit-manifest], MUST be used.

   [I-D.ietf-cose-aes-ctr-and-cbc] registers AES Counter mode (AES-CTR)
   and AES Cipher Block Chaining (AES-CBC) ciphers that do not offer
   integrity protection.  These ciphers are useful for the use cases
   that require firmware encryption on IoT devices.  For many other use
   cases where software packages, configuration information or
   personalization data needs to be encrypted, the use of Authenticated
   Encryption with Additional Data (AEAD) ciphers is preferred.

   The following sub-sections provide further information about the
   initialization vector (IV) selection for use with AES-CBC and AES-CTR
   in the firmware encryption context.  An IV MUST NOTE be re-used when
   the same key is used.  For this application, the IVs are not random
   but rather based on the slot/sector-combination in flash memory.  The
   text below assumes that the block-size of AES is (much) smaller than
   sector size.  The typical sector-size of flash memory is in the order
   of KiB.  Hence, multiple AES blocks need to be decrypted until an
   entire sector is completed.

7.1.  AES-CBC

   In AES-CBC a single IV is used for encryption of firmware belonging
   to a single sector since individual AES blocks are chained toghether,
   as shown in Figure 12.  The numbering of sectors in a slot MUST start
   with zero (0) and MUST increase by one with every sector till the end
   of the slot is reached.  The IV follows this numbering.

   For example, let us assume the slot size of a specific flash
   controller on an IoT device is 64 KiB, the sector size 4096 bytes (4
   KiB) and AES-128-CBC uses an AES-block size of 128 bit (16 bytes).
   Hence, sector 0 needs 4096/16=256 AES-128-CBC operations using IV 0.
   If the firmware image fills the entire slot then that slot contains
   16 sectors, i.e. IVs ranging from 0 to 15.














Tschofenig, et al.      Expires 15 February 2024               [Page 22]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


          P1              P2
           |              |
      IV--(+)    +-------(+)
           |     |        |
           |     |        |
       +-------+ |    +-------+
       |       | |    |       |
       |       | |    |       |
    k--|  E    | | k--|  E    |
       |       | |    |       |
       +-------+ |    +-------+
           |     |        |
           +-----+        |
           |              |
           |              |
           C1             C2

   Legend:
     Pi = Plaintext blocks
     Ci = Ciphertext blocks
     E = Encryption function
     k = Symmetric key
     (+) = XOR operation

                        Figure 12: AES-CBC Operation

7.2.  AES-CTR

   Unlike AES-CBC, AES-CTR uses an IV per AES operation, as shown in
   Figure 13.  Hence, when an image is encrypted using AES-CTR-128 or
   AES-CTR-256, the IV MUST start with zero (0) and MUST be incremented
   by one for each 16-byte plaintext block within the entire slot.

   Using the previous example with a slot size of 64 KiB, the sector
   size 4096 bytes and the AES plaintext block size of 16 byte requires
   IVs from 0 to 255 in the first sector and 16 * 256 IVs for the
   remaining sectors in the slot.














Tschofenig, et al.      Expires 15 February 2024               [Page 23]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


            IV1            IV2
             |              |
             |              |
             |              |
         +-------+      +-------+
         |       |      |       |
         |       |      |       |
      k--|  E    |   k--|  E    |
         |       |      |       |
         +-------+      +-------+
             |              |
        P1--(+)        P2--(+)
             |              |
             |              |
             C1             C2

   Legend:
     See previous diagram.

                        Figure 13: AES-CTR Operation

8.  Complete Examples

   The following manifests examplify how to deliver encrypted firmware
   and its encryption info to devices.

   The examples are signed using the following ECDSA secp256r1 key:

   -----BEGIN PRIVATE KEY-----
   MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgApZYjZCUGLM50VBC
   CjYStX+09jGmnyJPrpDLTz/hiXOhRANCAASEloEarguqq9JhVxie7NomvqqL8Rtv
   P+bitWWchdvArTsfKktsCYExwKNtrNHXi9OB3N+wnAUtszmR23M4tKiW
   -----END PRIVATE KEY-----

   The corresponding public key can be used to verify these examples:

   -----BEGIN PUBLIC KEY-----
   MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEhJaBGq4LqqvSYVcYnuzaJr6qi/Eb
   bz/m4rVlnIXbwK07HypLbAmBMcCjbazR14vTgdzfsJwFLbM5kdtzOLSolg==
   -----END PUBLIC KEY-----

   Each example uses SHA-256 as the digest function.

8.1.  AES Key Wrap Example with Write Directive

   The following SUIT manifest requests a parser to write and to decrypt
   the encrypted payload into a component with the suit-directive-write
   directive.



Tschofenig, et al.      Expires 15 February 2024               [Page 24]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   The SUIT manifest in diagnostic notation (with line breaks added for
   readability) is shown here:

   {::include examples/suit-manifest-aes-kw-content.diag.signed}

   In hex format, the SUIT manifest is this:

   {::include examples/suit-manifest-aes-kw-content.hex.signed}

8.2.  AES Key Wrap Example with Fetch + Copy Directives

   The following SUIT manifest requests a parser to fetch the encrypted
   payload and to stores it.  Then, the payload is decrypt and stored
   into another component with the suit-directive-copy directive.  This
   approach works well on constrained devices with execute-in-place
   flash memory.

   The SUIT manifest in diagnostic notation (with line breaks added for
   readability) is shown here:

   {::include examples/suit-manifest-aes-kw.diag.signed}

   In hex format, the SUIT manifest is this:

   {::include examples/suit-manifest-aes-kw.hex.signed}

9.  Security Considerations

   The algorithms described in this document assume that the party
   performing payload encryption

   *  shares a key-encryption key (KEK) with the recipient (for use with
      the AES Key Wrap scheme), or

   *  is in possession of the public key of the recipient (for use with
      ES-DH).

   Both cases require some upfront communication interaction to
   distribute these keys to the involved communication parties.  This
   interaction may be provided by an device management solution, as
   described in [RFC9019], or may be executed earlier in the lifecycle
   of the device, for example during manufacturing or during
   commissioning.  In addition to the keying material key identifiers
   and algorithm information needs to be provisioned.  This
   specification places no requirements on the structure of the key
   identifier.





Tschofenig, et al.      Expires 15 February 2024               [Page 25]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   To provide high security for AES Key Wrap it is important that the
   KEK is of high entropy, and that implementations protect the KEK from
   disclosure.  Compromise of the KEK may result in the disclosure of
   all key data protected with that KEK.

   Since the CEK is randomly generated, it must be ensured that the
   guidelines for random number generation in [RFC8937] are followed.

   In some cases third party companies analyse binaries for known
   security vulnerabilities.  With encrypted payloads this type of
   analysis is prevented.  Consequently, these third party companies
   either need to be given access to the plaintext binary before
   encryption or they need to become authorized recipients of the
   encrypted payloads.  In either case, it is necessary to explicitly
   consider those third parties in the software supply chain when such a
   binary analysis is desired.

   If an attacker alters the key distribution data then a recipient will
   decrypt the firmware image with an incorrect key.  This will lead to
   expending energy and flash cycles until the failure is detected.

   To mitigate this attack, a new parameter, called suit-cek-
   verification, is added to the manifest.  The suit-cek-verification
   parameter is optional to implement and optional to use.  When used,
   it reduces the risk of a battery exhaustion attack against the IoT
   device.

10.  IANA Considerations

   IANA is asked to add two values to the SUIT_Parameters registry
   established by [I-D.ietf-suit-manifest].

   Label      Name                 Reference
   -----------------------------------------
   TBD1       Encryption Info      Section 4

   [Editor's Note: - TBD1: Proposed 19 ]

11.  References

11.1.  Normative References

   [I-D.ietf-cose-aes-ctr-and-cbc]
              Housley, R. and H. Tschofenig, "CBOR Object Signing and
              Encryption (COSE): AES-CTR and AES-CBC", Work in Progress,
              Internet-Draft, draft-ietf-cose-aes-ctr-and-cbc-06, 25 May
              2023, <https://datatracker.ietf.org/doc/html/draft-ietf-
              cose-aes-ctr-and-cbc-06>.



Tschofenig, et al.      Expires 15 February 2024               [Page 26]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   [I-D.ietf-suit-manifest]
              Moran, B., Tschofenig, H., Birkholz, H., Zandberg, K., and
              O. Rønningstad, "A Concise Binary Object Representation
              (CBOR)-based Serialization Format for the Software Updates
              for Internet of Things (SUIT) Manifest", Work in Progress,
              Internet-Draft, draft-ietf-suit-manifest-22, 27 February
              2023, <https://datatracker.ietf.org/doc/html/draft-ietf-
              suit-manifest-22>.

   [I-D.ietf-suit-trust-domains]
              Moran, B. and K. Takayama, "SUIT Manifest Extensions for
              Multiple Trust Domains", Work in Progress, Internet-Draft,
              draft-ietf-suit-trust-domains-04, 7 July 2023,
              <https://datatracker.ietf.org/doc/html/draft-ietf-suit-
              trust-domains-04>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC3394]  Schaad, J. and R. Housley, "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, DOI 10.17487/RFC3394,
              September 2002, <https://www.rfc-editor.org/rfc/rfc3394>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9052]  Schaad, J., "CBOR Object Signing and Encryption (COSE):
              Structures and Process", STD 96, RFC 9052,
              DOI 10.17487/RFC9052, August 2022,
              <https://www.rfc-editor.org/rfc/rfc9052>.

   [RFC9053]  Schaad, J., "CBOR Object Signing and Encryption (COSE):
              Initial Algorithms", RFC 9053, DOI 10.17487/RFC9053,
              August 2022, <https://www.rfc-editor.org/rfc/rfc9053>.

11.2.  Informative References

   [iana-suit]
              Internet Assigned Numbers Authority, "IANA SUIT Manifest
              Registry", 2023, <TBD>.








Tschofenig, et al.      Expires 15 February 2024               [Page 27]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/rfc/rfc5280>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <https://www.rfc-editor.org/rfc/rfc5652>.

   [RFC8937]  Cremers, C., Garratt, L., Smyshlyaev, S., Sullivan, N.,
              and C. Wood, "Randomness Improvements for Security
              Protocols", RFC 8937, DOI 10.17487/RFC8937, October 2020,
              <https://www.rfc-editor.org/rfc/rfc8937>.

   [RFC9019]  Moran, B., Tschofenig, H., Brown, D., and M. Meriac, "A
              Firmware Update Architecture for Internet of Things",
              RFC 9019, DOI 10.17487/RFC9019, April 2021,
              <https://www.rfc-editor.org/rfc/rfc9019>.

   [RFC9124]  Moran, B., Tschofenig, H., and H. Birkholz, "A Manifest
              Information Model for Firmware Updates in Internet of
              Things (IoT) Devices", RFC 9124, DOI 10.17487/RFC9124,
              January 2022, <https://www.rfc-editor.org/rfc/rfc9124>.

   [ROP]      Wikipedia, "Return-Oriented Programming", March 2023,
              <https://en.wikipedia.org/wiki/Return-
              oriented_programming>.

Appendix A.  Acknowledgements

   We would like to thank Henk Birkholz for his feedback on the CDDL
   description in this document.  Additionally, we would like to thank
   Michael Richardson, Øyvind Rønningstad, Dave Thaler, Laurence
   Lundblade, Russ Housley, and Carsten Bormann for their review
   feedback.  Finally, we would like to thank Dick Brooks for making us
   aware of the challenges firmware encryption imposes on binary
   analysis.

Authors' Addresses

   Hannes Tschofenig
   Email: hannes.tschofenig@gmx.net


   Russ Housley
   Vigil Security, LLC
   Email: housley@vigilsec.com



Tschofenig, et al.      Expires 15 February 2024               [Page 28]

Internet-Draft    Encrypted Payloads in SUIT Manifests       August 2023


   Brendan Moran
   Arm Limited
   Email: Brendan.Moran@arm.com


   David Brown
   Linaro
   Email: david.brown@linaro.org


   Ken Takayama
   SECOM CO., LTD.
   Email: ken.takayama.ietf@gmail.com






































Tschofenig, et al.      Expires 15 February 2024               [Page 29]
